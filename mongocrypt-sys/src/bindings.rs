/* automatically generated by rust-bindgen 0.59.2 */

extern "C" {
    #[doc = " Returns the version string for libmongocrypt."]
    #[doc = ""]
    #[doc = " @param[out] len  An optional length of the returned string. May be NULL."]
    #[doc = " @returns a NULL terminated version string for libmongocrypt."]
    pub fn mongocrypt_version(len: *mut u32) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mongocrypt_binary_t {
    _unused: [u8; 0],
}
#[doc = " A non-owning view of a byte buffer."]
#[doc = ""]
#[doc = " When constructing a mongocrypt_binary_t it is the responsibility of the"]
#[doc = " caller to maintain the lifetime of the viewed data. However, all public"]
#[doc = " functions that take a mongocrypt_binary_t as an argument will make a copy of"]
#[doc = " the viewed data. For example, the following is valid:"]
#[doc = ""]
#[doc = " @code{.c}"]
#[doc = " mongocrypt_binary_t bin = mongocrypt_binary_new_from_data(mydata, mylen);"]
#[doc = " assert (mongocrypt_setopt_kms_provider_local (crypt), bin);"]
#[doc = " // The viewed data of bin has been copied. Ok to free the view and the data."]
#[doc = " mongocrypt_binary_destroy (bin);"]
#[doc = " my_free_fn (mydata);"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " Functions with a mongocrypt_binary_t* out guarantee the lifetime of the"]
#[doc = " viewed data to live as long as the parent object. For example, @ref"]
#[doc = " mongocrypt_ctx_mongo_op guarantees that the viewed data of"]
#[doc = " mongocrypt_binary_t is valid until the parent ctx is destroyed with @ref"]
#[doc = " mongocrypt_ctx_destroy."]
pub type mongocrypt_binary_t = _mongocrypt_binary_t;
extern "C" {
    #[doc = " Create a new non-owning view of a buffer (data + length)."]
    #[doc = ""]
    #[doc = " Use this to create a mongocrypt_binary_t used for output parameters."]
    #[doc = ""]
    #[doc = " @returns A new mongocrypt_binary_t."]
    pub fn mongocrypt_binary_new() -> *mut mongocrypt_binary_t;
}
extern "C" {
    #[doc = " Create a new non-owning view of a buffer (data + length)."]
    #[doc = ""]
    #[doc = " @param[in] data A pointer to an array of bytes. This data is not copied. @p"]
    #[doc = " data must outlive the binary object."]
    #[doc = " @param[in] len The length of the @p data byte array."]
    #[doc = ""]
    #[doc = " @returns A new @ref mongocrypt_binary_t."]
    pub fn mongocrypt_binary_new_from_data(data: *mut u8, len: u32) -> *mut mongocrypt_binary_t;
}
extern "C" {
    #[doc = " Get a pointer to the viewed data."]
    #[doc = ""]
    #[doc = " @param[in] binary The @ref mongocrypt_binary_t."]
    #[doc = ""]
    #[doc = " @returns A pointer to the viewed data."]
    pub fn mongocrypt_binary_data(binary: *const mongocrypt_binary_t) -> *mut u8;
}
extern "C" {
    #[doc = " Get the length of the viewed data."]
    #[doc = ""]
    #[doc = " @param[in] binary The @ref mongocrypt_binary_t."]
    #[doc = ""]
    #[doc = " @returns The length of the viewed data."]
    pub fn mongocrypt_binary_len(binary: *const mongocrypt_binary_t) -> u32;
}
extern "C" {
    #[doc = " Free the @ref mongocrypt_binary_t."]
    #[doc = ""]
    #[doc = " This does not free the viewed data."]
    #[doc = ""]
    #[doc = " @param[in] binary The mongocrypt_binary_t destroy."]
    pub fn mongocrypt_binary_destroy(binary: *mut mongocrypt_binary_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mongocrypt_status_t {
    _unused: [u8; 0],
}
#[doc = " Indicates success or contains error information."]
#[doc = ""]
#[doc = " Functions like @ref mongocrypt_ctx_encrypt_init follow a pattern to expose a"]
#[doc = " status. A boolean is returned. True indicates success, and false indicates"]
#[doc = " failure. On failure a status on the handle is set, and is accessible with a"]
#[doc = " corresponding (handle)_status function. E.g. @ref mongocrypt_ctx_status."]
pub type mongocrypt_status_t = _mongocrypt_status_t;
pub const mongocrypt_status_type_t_MONGOCRYPT_STATUS_OK: mongocrypt_status_type_t = 0;
pub const mongocrypt_status_type_t_MONGOCRYPT_STATUS_ERROR_CLIENT: mongocrypt_status_type_t = 1;
pub const mongocrypt_status_type_t_MONGOCRYPT_STATUS_ERROR_KMS: mongocrypt_status_type_t = 2;
pub const mongocrypt_status_type_t_MONGOCRYPT_STATUS_ERROR_CRYPT_SHARED: mongocrypt_status_type_t =
    3;
#[doc = " Indicates the type of error."]
pub type mongocrypt_status_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new status object."]
    #[doc = ""]
    #[doc = " Use a new status object to retrieve the status from a handle by passing"]
    #[doc = " this as an out-parameter to functions like @ref mongocrypt_ctx_status."]
    #[doc = " When done, destroy it with @ref mongocrypt_status_destroy."]
    #[doc = ""]
    #[doc = " @returns A new status object."]
    pub fn mongocrypt_status_new() -> *mut mongocrypt_status_t;
}
extern "C" {
    #[doc = " Set a status object with message, type, and code."]
    #[doc = ""]
    #[doc = " Use this to set the @ref mongocrypt_status_t given in the crypto hooks."]
    #[doc = ""]
    #[doc = " @param[in] type The status type."]
    #[doc = " @param[in] code The status code."]
    #[doc = " @param[in] message The message."]
    #[doc = " @param[in] message_len Due to historical behavior, pass 1 + the string length"]
    #[doc = " of @p message (which differs from other functions accepting string"]
    #[doc = " arguments)."]
    #[doc = " Alternatively, if message is NULL terminated this may be -1 to tell"]
    #[doc = " mongocrypt"]
    #[doc = " to determine the string's length with strlen."]
    #[doc = ""]
    pub fn mongocrypt_status_set(
        status: *mut mongocrypt_status_t,
        type_: mongocrypt_status_type_t,
        code: u32,
        message: *const ::std::os::raw::c_char,
        message_len: i32,
    );
}
extern "C" {
    #[doc = " Indicates success or the type of error."]
    #[doc = ""]
    #[doc = " @param[in] status The status object."]
    #[doc = ""]
    #[doc = " @returns A @ref mongocrypt_status_type_t."]
    pub fn mongocrypt_status_type(status: *mut mongocrypt_status_t) -> mongocrypt_status_type_t;
}
extern "C" {
    #[doc = " Get an error code or 0."]
    #[doc = ""]
    #[doc = " @param[in] status The status object."]
    #[doc = ""]
    #[doc = " @returns An error code."]
    pub fn mongocrypt_status_code(status: *mut mongocrypt_status_t) -> u32;
}
extern "C" {
    #[doc = " Get the error message associated with a status or NULL."]
    #[doc = ""]
    #[doc = " @param[in] status The status object."]
    #[doc = " @param[out] len An optional length of the returned string (excluding the"]
    #[doc = " trailing NULL byte). May be NULL."]
    #[doc = ""]
    #[doc = " @returns A NULL terminated error message or NULL."]
    pub fn mongocrypt_status_message(
        status: *mut mongocrypt_status_t,
        len: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns true if the status indicates success."]
    #[doc = ""]
    #[doc = " @param[in] status The status to check."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_status_ok(status: *mut mongocrypt_status_t) -> bool;
}
extern "C" {
    #[doc = " Free the memory for a status object."]
    #[doc = ""]
    #[doc = " @param[in] status The status to destroy."]
    pub fn mongocrypt_status_destroy(status: *mut mongocrypt_status_t);
}
pub const mongocrypt_log_level_t_MONGOCRYPT_LOG_LEVEL_FATAL: mongocrypt_log_level_t = 0;
pub const mongocrypt_log_level_t_MONGOCRYPT_LOG_LEVEL_ERROR: mongocrypt_log_level_t = 1;
pub const mongocrypt_log_level_t_MONGOCRYPT_LOG_LEVEL_WARNING: mongocrypt_log_level_t = 2;
pub const mongocrypt_log_level_t_MONGOCRYPT_LOG_LEVEL_INFO: mongocrypt_log_level_t = 3;
pub const mongocrypt_log_level_t_MONGOCRYPT_LOG_LEVEL_TRACE: mongocrypt_log_level_t = 4;
#[doc = " Indicates the type of log message."]
pub type mongocrypt_log_level_t = ::std::os::raw::c_uint;
#[doc = " A log callback function. Set a custom log callback with @ref"]
#[doc = " mongocrypt_setopt_log_handler."]
#[doc = ""]
#[doc = " @param[in] message A NULL terminated message."]
#[doc = " @param[in] message_len The length of message."]
#[doc = " @param[in] ctx A context provided by the caller of @ref"]
#[doc = " mongocrypt_setopt_log_handler."]
pub type mongocrypt_log_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: mongocrypt_log_level_t,
        message: *const ::std::os::raw::c_char,
        message_len: u32,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mongocrypt_t {
    _unused: [u8; 0],
}
#[doc = " The top-level handle to libmongocrypt."]
#[doc = ""]
#[doc = " Create a mongocrypt_t handle to perform operations within libmongocrypt:"]
#[doc = " encryption, decryption, registering log callbacks, etc."]
#[doc = ""]
#[doc = " Functions on a mongocrypt_t are thread safe, though functions on derived"]
#[doc = " handles (e.g. mongocrypt_ctx_t) are not and must be owned by a single"]
#[doc = " thread. See each handle's documentation for thread-safety considerations."]
#[doc = ""]
#[doc = " Multiple mongocrypt_t handles may be created."]
pub type mongocrypt_t = _mongocrypt_t;
extern "C" {
    #[doc = " Allocate a new @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " Set options using mongocrypt_setopt_* functions, then initialize with @ref"]
    #[doc = " mongocrypt_init. When done with the @ref mongocrypt_t, free with @ref"]
    #[doc = " mongocrypt_destroy."]
    #[doc = ""]
    #[doc = " @returns A new @ref mongocrypt_t object."]
    pub fn mongocrypt_new() -> *mut mongocrypt_t;
}
extern "C" {
    #[doc = " Set a handler on the @ref mongocrypt_t object to get called on every log"]
    #[doc = " message."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] log_fn The log callback."]
    #[doc = " @param[in] log_ctx A context passed as an argument to the log callback every"]
    #[doc = " invocation."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_setopt_log_handler(
        crypt: *mut mongocrypt_t,
        log_fn: mongocrypt_log_fn_t,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Configure an AWS KMS provider on the @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " This has been superseded by the more flexible:"]
    #[doc = " @ref mongocrypt_setopt_kms_providers"]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] aws_access_key_id The AWS access key ID used to generate KMS"]
    #[doc = " messages."]
    #[doc = " @param[in] aws_access_key_id_len The string length (in bytes) of @p"]
    #[doc = " aws_access_key_id. Pass -1 to determine the string length with strlen (must"]
    #[doc = " be NULL terminated)."]
    #[doc = " @param[in] aws_secret_access_key The AWS secret access key used to generate"]
    #[doc = " KMS messages."]
    #[doc = " @param[in] aws_secret_access_key_len The string length (in bytes) of @p"]
    #[doc = " aws_secret_access_key. Pass -1 to determine the string length with strlen"]
    #[doc = " (must be NULL terminated)."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_setopt_kms_provider_aws(
        crypt: *mut mongocrypt_t,
        aws_access_key_id: *const ::std::os::raw::c_char,
        aws_access_key_id_len: i32,
        aws_secret_access_key: *const ::std::os::raw::c_char,
        aws_secret_access_key_len: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Configure a local KMS provider on the @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " This has been superseded by the more flexible:"]
    #[doc = " @ref mongocrypt_setopt_kms_providers"]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] key A 96 byte master key used to encrypt and decrypt key vault"]
    #[doc = " keys. The viewed data is copied. It is valid to destroy @p key with @ref"]
    #[doc = " mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_setopt_kms_provider_local(
        crypt: *mut mongocrypt_t,
        key: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Configure KMS providers with a BSON document."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] kms_providers A BSON document mapping the KMS provider names"]
    #[doc = " to credentials. Set a KMS provider value to an empty document to supply"]
    #[doc = " credentials on-demand with @ref mongocrypt_ctx_provide_kms_providers."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_setopt_kms_providers(
        crypt: *mut mongocrypt_t,
        kms_providers: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a local schema map for encryption."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] schema_map A BSON document representing the schema map supplied by"]
    #[doc = " the user. The keys are collection namespaces and values are JSON schemas. The"]
    #[doc = " viewed data copied. It is valid to destroy @p schema_map with @ref"]
    #[doc = " mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @p crypt has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_status"]
    pub fn mongocrypt_setopt_schema_map(
        crypt: *mut mongocrypt_t,
        schema_map: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a local EncryptedFieldConfigMap for encryption."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] efc_map A BSON document representing the EncryptedFieldConfigMap"]
    #[doc = " supplied by the user. The keys are collection namespaces and values are"]
    #[doc = " EncryptedFieldConfigMap documents. The viewed data copied. It is valid to"]
    #[doc = " destroy @p efc_map with @ref mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @p crypt has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_status"]
    pub fn mongocrypt_setopt_encrypted_field_config_map(
        crypt: *mut mongocrypt_t,
        efc_map: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Append an additional search directory to the search path for loading"]
    #[doc = " the crypt_shared dynamic library."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object to update"]
    #[doc = " @param[in] path A null-terminated sequence of bytes for the search path. On"]
    #[doc = " some filesystems, this may be arbitrary bytes. On other filesystems, this may"]
    #[doc = " be required to be a valid UTF-8 code unit sequence. If the leading element of"]
    #[doc = " the path is the literal string \"$ORIGIN\", that substring will be replaced"]
    #[doc = " with the directory path containing the executable libmongocrypt module. If"]
    #[doc = " the path string is literal \"$SYSTEM\", then libmongocrypt will defer to the"]
    #[doc = " system's library resolution mechanism to find the crypt_shared library."]
    #[doc = ""]
    #[doc = " @note If no crypt_shared dynamic library is found in any of the directories"]
    #[doc = " specified by the search paths loaded here, @ref mongocrypt_init() will still"]
    #[doc = " succeed and continue to operate without crypt_shared."]
    #[doc = ""]
    #[doc = " @note The search paths are searched in the order that they are appended. This"]
    #[doc = " allows one to provide a precedence in how the library will be discovered. For"]
    #[doc = " example, appending known directories before appending \"$SYSTEM\" will allow"]
    #[doc = " one to supersede the system's installed library, but still fall-back to it if"]
    #[doc = " the library wasn't found otherwise. If one does not ever append \"$SYSTEM\","]
    #[doc = " then the system's library-search mechanism will never be consulted."]
    #[doc = ""]
    #[doc = " @note If an absolute path to the library is specified using"]
    #[doc = " @ref mongocrypt_setopt_set_crypt_shared_lib_path_override, then paths"]
    #[doc = " appended here will have no effect."]
    pub fn mongocrypt_setopt_append_crypt_shared_lib_search_path(
        crypt: *mut mongocrypt_t,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set a single override path for loading the crypt_shared dynamic"]
    #[doc = " library."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object to update"]
    #[doc = " @param[in] path A null-terminated sequence of bytes for a path to the"]
    #[doc = " crypt_shared dynamic library. On some filesystems, this may be arbitrary"]
    #[doc = " bytes. On other filesystems, this may be required to be a valid UTF-8 code"]
    #[doc = " unit sequence. If the leading element of the path is the literal string"]
    #[doc = " `$ORIGIN`, that substring will be replaced with the directory path containing"]
    #[doc = " the executable libmongocrypt module."]
    #[doc = ""]
    #[doc = " @note This function will do no IO nor path validation. All validation will"]
    #[doc = " occur during the call to @ref mongocrypt_init."]
    #[doc = ""]
    #[doc = " @note If a crypt_shared library path override is specified here, then no"]
    #[doc = " paths given to @ref mongocrypt_setopt_append_crypt_shared_lib_search_path"]
    #[doc = " will be consulted when opening the crypt_shared library."]
    #[doc = ""]
    #[doc = " @note If a path is provided via this API and @ref mongocrypt_init fails to"]
    #[doc = " initialize a valid crypt_shared library instance for the path specified, then"]
    #[doc = " the initialization of mongocrypt_t will fail with an error."]
    pub fn mongocrypt_setopt_set_crypt_shared_lib_path_override(
        crypt: *mut mongocrypt_t,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Opt-into handling the MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS state."]
    #[doc = ""]
    #[doc = " If set, before entering the MONGOCRYPT_CTX_NEED_KMS state,"]
    #[doc = " contexts may enter the MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS state"]
    #[doc = " and then wait for credentials to be supplied through"]
    #[doc = " @ref mongocrypt_ctx_provide_kms_providers."]
    #[doc = ""]
    #[doc = " A context will only enter MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"]
    #[doc = " if an empty document was set for a KMS provider in @ref"]
    #[doc = " mongocrypt_setopt_kms_providers."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object to update"]
    pub fn mongocrypt_setopt_use_need_kms_credentials_state(crypt: *mut mongocrypt_t);
}
extern "C" {
    #[doc = " Initialize new @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " Set options before using @ref mongocrypt_setopt_kms_provider_local, @ref"]
    #[doc = " mongocrypt_setopt_kms_provider_aws, or @ref mongocrypt_setopt_log_handler."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status Failure may occur if previously"]
    #[doc = " set"]
    #[doc = " options are invalid."]
    pub fn mongocrypt_init(crypt: *mut mongocrypt_t) -> bool;
}
extern "C" {
    #[doc = " Get the status associated with a @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[out] status Receives the status."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_status(crypt: *mut mongocrypt_t, status: *mut mongocrypt_status_t) -> bool;
}
extern "C" {
    #[doc = " Destroy the @ref mongocrypt_t object."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object to destroy."]
    pub fn mongocrypt_destroy(crypt: *mut mongocrypt_t);
}
extern "C" {
    #[doc = " Obtain a nul-terminated version string of the loaded crypt_shared dynamic"]
    #[doc = " library, if available."]
    #[doc = ""]
    #[doc = " If no crypt_shared was successfully loaded, this function returns NULL."]
    #[doc = ""]
    #[doc = " @param[in] crypt The mongocrypt_t object after a successful call to"]
    #[doc = " mongocrypt_init."]
    #[doc = " @param[out] len An optional output parameter to which the length of the"]
    #[doc = " returned string is written. If provided and no crypt_shared library was"]
    #[doc = " loaded, zero is written to *len."]
    #[doc = ""]
    #[doc = " @return A nul-terminated string of the dynamically loaded crypt_shared"]
    #[doc = " library."]
    #[doc = ""]
    #[doc = " @note For a numeric value that can be compared against, use"]
    #[doc = " @ref mongocrypt_crypt_shared_lib_version."]
    pub fn mongocrypt_crypt_shared_lib_version_string(
        crypt: *const mongocrypt_t,
        len: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Obtain a 64-bit constant encoding the version of the loaded"]
    #[doc = " crypt_shared library, if available."]
    #[doc = ""]
    #[doc = " @param[in] crypt The mongocrypt_t object after a successul call to"]
    #[doc = " mongocrypt_init."]
    #[doc = ""]
    #[doc = " @return A 64-bit encoded version number, with the version encoded as four"]
    #[doc = " sixteen-bit integers, or zero if no crypt_shared library was loaded."]
    #[doc = ""]
    #[doc = " The version is encoded as four 16-bit numbers, from high to low:"]
    #[doc = ""]
    #[doc = " - Major version"]
    #[doc = " - Minor version"]
    #[doc = " - Revision"]
    #[doc = " - Reserved"]
    #[doc = ""]
    #[doc = " For example, version 6.2.1 would be encoded as: 0x0006'0002'0001'0000"]
    pub fn mongocrypt_crypt_shared_lib_version(crypt: *const mongocrypt_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mongocrypt_ctx_t {
    _unused: [u8; 0],
}
#[doc = " Manages the state machine for encryption or decryption."]
pub type mongocrypt_ctx_t = _mongocrypt_ctx_t;
extern "C" {
    #[doc = " Create a new uninitialized @ref mongocrypt_ctx_t."]
    #[doc = ""]
    #[doc = " Initialize the context with functions like @ref mongocrypt_ctx_encrypt_init."]
    #[doc = " When done, destroy it with @ref mongocrypt_ctx_destroy."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @returns A new context."]
    pub fn mongocrypt_ctx_new(crypt: *mut mongocrypt_t) -> *mut mongocrypt_ctx_t;
}
extern "C" {
    #[doc = " Get the status associated with a @ref mongocrypt_ctx_t object."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[out] status Receives the status."]
    #[doc = ""]
    #[doc = " @returns True if the output is an ok status, false if it is an error"]
    #[doc = " status."]
    #[doc = ""]
    #[doc = " @see mongocrypt_status_ok"]
    pub fn mongocrypt_ctx_status(
        ctx: *mut mongocrypt_ctx_t,
        status: *mut mongocrypt_status_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the key id to use for explicit encryption."]
    #[doc = ""]
    #[doc = " It is an error to set both this and the key alt name."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] key_id The binary corresponding to the _id (a UUID) of the data"]
    #[doc = " key to use from the key vault collection. Note, the UUID must be encoded with"]
    #[doc = " RFC-4122 byte order. The viewed data is copied. It is valid to destroy"]
    #[doc = " @p key_id with @ref mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_key_id(
        ctx: *mut mongocrypt_ctx_t,
        key_id: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the keyAltName to use for explicit encryption or"]
    #[doc = " data key creation."]
    #[doc = ""]
    #[doc = " Pass the binary encoding a BSON document like the following:"]
    #[doc = ""]
    #[doc = "   { \"keyAltName\" : (BSON UTF8 value) }"]
    #[doc = ""]
    #[doc = " For explicit encryption, it is an error to set both the keyAltName"]
    #[doc = " and the key id."]
    #[doc = ""]
    #[doc = " For creating data keys, call this function repeatedly to set"]
    #[doc = " multiple keyAltNames."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] key_alt_name The name to use. The viewed data is copied. It is"]
    #[doc = " valid to destroy @p key_alt_name with @ref mongocrypt_binary_destroy"]
    #[doc = " immediately after."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_key_alt_name(
        ctx: *mut mongocrypt_ctx_t,
        key_alt_name: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the keyMaterial to use for encrypting data."]
    #[doc = ""]
    #[doc = " Pass the binary encoding of a BSON document like the following:"]
    #[doc = ""]
    #[doc = "   { \"keyMaterial\" : (BSON BINARY value) }"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] key_material The data encryption key to use. The viewed data is"]
    #[doc = " copied. It is valid to destroy @p key_material with @ref"]
    #[doc = " mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_key_material(
        ctx: *mut mongocrypt_ctx_t,
        key_material: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the algorithm used for encryption to either"]
    #[doc = " deterministic or random encryption. This value"]
    #[doc = " should only be set when using explicit encryption."]
    #[doc = ""]
    #[doc = " If -1 is passed in for \"len\", then \"algorithm\" is"]
    #[doc = " assumed to be a null-terminated string."]
    #[doc = ""]
    #[doc = " Valid values for algorithm are:"]
    #[doc = "   \"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\""]
    #[doc = "   \"AEAD_AES_256_CBC_HMAC_SHA_512-Random\""]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] algorithm A string specifying the algorithm to"]
    #[doc = " use for encryption."]
    #[doc = " @param[in] len The length of the algorithm string."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_algorithm(
        ctx: *mut mongocrypt_ctx_t,
        algorithm: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Identify the AWS KMS master key to use for creating a data key."]
    #[doc = ""]
    #[doc = " This has been superseded by the more flexible:"]
    #[doc = " @ref mongocrypt_ctx_setopt_key_encryption_key"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] region The AWS region."]
    #[doc = " @param[in] region_len The string length of @p region. Pass -1 to determine"]
    #[doc = " the string length with strlen (must be NULL terminated)."]
    #[doc = " @param[in] cmk The Amazon Resource Name (ARN) of the customer master key"]
    #[doc = " (CMK)."]
    #[doc = " @param[in] cmk_len The string length of @p cmk_len. Pass -1 to determine the"]
    #[doc = " string length with strlen (must be NULL terminated)."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_masterkey_aws(
        ctx: *mut mongocrypt_ctx_t,
        region: *const ::std::os::raw::c_char,
        region_len: i32,
        cmk: *const ::std::os::raw::c_char,
        cmk_len: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Identify a custom AWS endpoint when creating a data key."]
    #[doc = " This is used internally to construct the correct HTTP request"]
    #[doc = " (with the Host header set to this endpoint). This endpoint"]
    #[doc = " is persisted in the new data key, and will be returned via"]
    #[doc = " @ref mongocrypt_kms_ctx_endpoint."]
    #[doc = ""]
    #[doc = " This has been superseded by the more flexible:"]
    #[doc = " @ref mongocrypt_ctx_setopt_key_encryption_key"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] endpoint The endpoint."]
    #[doc = " @param[in] endpoint_len The string length of @p endpoint. Pass -1 to"]
    #[doc = " determine the string length with strlen (must be NULL terminated)."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_masterkey_aws_endpoint(
        ctx: *mut mongocrypt_ctx_t,
        endpoint: *const ::std::os::raw::c_char,
        endpoint_len: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the master key to \"local\" for creating a data key."]
    #[doc = " This has been superseded by the more flexible:"]
    #[doc = " @ref mongocrypt_ctx_setopt_key_encryption_key"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_masterkey_local(ctx: *mut mongocrypt_ctx_t) -> bool;
}
extern "C" {
    #[doc = " Set key encryption key document for creating a data key or for rewrapping"]
    #[doc = " datakeys."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] bin BSON representing the key encryption key document with"]
    #[doc = " an additional \"provider\" field. The following forms are accepted:"]
    #[doc = ""]
    #[doc = " AWS"]
    #[doc = " {"]
    #[doc = "    provider: \"aws\","]
    #[doc = "    region: <string>,"]
    #[doc = "    key: <string>,"]
    #[doc = "    endpoint: <optional string>"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " Azure"]
    #[doc = " {"]
    #[doc = "    provider: \"azure\","]
    #[doc = "    keyVaultEndpoint: <string>,"]
    #[doc = "    keyName: <string>,"]
    #[doc = "    keyVersion: <optional string>"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " GCP"]
    #[doc = " {"]
    #[doc = "    provider: \"gcp\","]
    #[doc = "    projectId: <string>,"]
    #[doc = "    location: <string>,"]
    #[doc = "    keyRing: <string>,"]
    #[doc = "    keyName: <string>,"]
    #[doc = "    keyVersion: <string>,"]
    #[doc = "    endpoint: <optional string>"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " Local"]
    #[doc = " {"]
    #[doc = "    provider: \"local\""]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " KMIP"]
    #[doc = " {"]
    #[doc = "    provider: \"kmip\","]
    #[doc = "    keyId: <optional string>"]
    #[doc = "    endpoint: <string>"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, and error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status."]
    pub fn mongocrypt_ctx_setopt_key_encryption_key(
        ctx: *mut mongocrypt_ctx_t,
        bin: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize a context to create a data key."]
    #[doc = ""]
    #[doc = " Associated options:"]
    #[doc = " - @ref mongocrypt_ctx_setopt_masterkey_aws"]
    #[doc = " - @ref mongocrypt_ctx_setopt_masterkey_aws_endpoint"]
    #[doc = " - @ref mongocrypt_ctx_setopt_masterkey_local"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    #[doc = " @pre A master key option has been set, and an associated KMS provider"]
    #[doc = " has been set on the parent @ref mongocrypt_t."]
    pub fn mongocrypt_ctx_datakey_init(ctx: *mut mongocrypt_ctx_t) -> bool;
}
extern "C" {
    #[doc = " Initialize a context for encryption."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] db The database name."]
    #[doc = " @param[in] db_len The byte length of @p db. Pass -1 to determine the string"]
    #[doc = " length with strlen (must"]
    #[doc = " be NULL terminated)."]
    #[doc = " @param[in] cmd The BSON command to be encrypted. The viewed data is copied."]
    #[doc = " It is valid to destroy @p cmd with @ref mongocrypt_binary_destroy immediately"]
    #[doc = " after."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_encrypt_init(
        ctx: *mut mongocrypt_ctx_t,
        db: *const ::std::os::raw::c_char,
        db_len: i32,
        cmd: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Explicit helper method to encrypt a single BSON object. Contexts"]
    #[doc = " created for explicit encryption will not go through mongocryptd."]
    #[doc = ""]
    #[doc = " To specify a key_id, algorithm, or iv to use, please use the"]
    #[doc = " corresponding mongocrypt_setopt methods before calling this."]
    #[doc = ""]
    #[doc = " This method expects the passed-in BSON to be of the form:"]
    #[doc = " { \"v\" : BSON value to encrypt }"]
    #[doc = ""]
    #[doc = " Associated options for FLE 1:"]
    #[doc = " - @ref mongocrypt_ctx_setopt_key_id"]
    #[doc = " - @ref mongocrypt_ctx_setopt_key_alt_name"]
    #[doc = " - @ref mongocrypt_ctx_setopt_algorithm"]
    #[doc = ""]
    #[doc = " Associated options for Queryable Encryption:"]
    #[doc = " - @ref mongocrypt_ctx_setopt_key_id"]
    #[doc = " - @ref mongocrypt_ctx_setopt_index_key_id"]
    #[doc = " - @ref mongocrypt_ctx_setopt_contention_factor"]
    #[doc = " - @ref mongocrypt_ctx_setopt_query_type"]
    #[doc = ""]
    #[doc = " An error is returned if FLE 1 and Queryable Encryption incompatible options"]
    #[doc = " are set."]
    #[doc = ""]
    #[doc = " @param[in] ctx A @ref mongocrypt_ctx_t."]
    #[doc = " @param[in] msg A @ref mongocrypt_binary_t the plaintext BSON value. The"]
    #[doc = " viewed data is copied. It is valid to destroy @p msg with @ref"]
    #[doc = " mongocrypt_binary_destroy immediately after."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_explicit_encrypt_init(
        ctx: *mut mongocrypt_ctx_t,
        msg: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize a context for decryption."]
    #[doc = ""]
    #[doc = " This method expects the passed-in BSON to be of the form:"]
    #[doc = " { \"v\" : BSON value to encrypt }"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] doc The document to be decrypted. The viewed data is copied. It is"]
    #[doc = " valid to destroy @p doc with @ref mongocrypt_binary_destroy immediately"]
    #[doc = " after."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_decrypt_init(
        ctx: *mut mongocrypt_ctx_t,
        doc: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Explicit helper method to decrypt a single BSON object."]
    #[doc = ""]
    #[doc = " Pass the binary encoding of a BSON document containing the BSON value to"]
    #[doc = " encrypt like the following:"]
    #[doc = ""]
    #[doc = "   { \"v\" : (BSON BINARY value of subtype 6) }"]
    #[doc = ""]
    #[doc = " @param[in] ctx A @ref mongocrypt_ctx_t."]
    #[doc = " @param[in] msg A @ref mongocrypt_binary_t the encrypted BSON. The viewed data"]
    #[doc = " is copied. It is valid to destroy @p msg with @ref mongocrypt_binary_destroy"]
    #[doc = " immediately after."]
    pub fn mongocrypt_ctx_explicit_decrypt_init(
        ctx: *mut mongocrypt_ctx_t,
        msg: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Initialize a context to rewrap datakeys."]
    #[doc = ""]
    #[doc = " Associated options:"]
    #[doc = " - @ref mongocrypt_ctx_setopt_key_encryption_key"]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] filter The filter to use for the find command on the key vault"]
    #[doc = " collection to retrieve datakeys to rewrap."]
    #[doc = " @return A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status."]
    pub fn mongocrypt_ctx_rewrap_many_datakey_init(
        ctx: *mut mongocrypt_ctx_t,
        filter: *mut mongocrypt_binary_t,
    ) -> bool;
}
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_ERROR: mongocrypt_ctx_state_t = 0;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: mongocrypt_ctx_state_t = 1;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: mongocrypt_ctx_state_t = 2;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_NEED_MONGO_KEYS: mongocrypt_ctx_state_t = 3;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_NEED_KMS: mongocrypt_ctx_state_t = 4;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: mongocrypt_ctx_state_t = 7;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_READY: mongocrypt_ctx_state_t = 5;
pub const mongocrypt_ctx_state_t_MONGOCRYPT_CTX_DONE: mongocrypt_ctx_state_t = 6;
#[doc = " Indicates the state of the @ref mongocrypt_ctx_t. Each state requires"]
#[doc = " different handling. See [the integration"]
#[doc = " guide](https://github.com/mongodb/libmongocrypt/blob/master/integrating.md#state-machine)"]
#[doc = " for information on what to do for each state."]
pub type mongocrypt_ctx_state_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the current state of a context."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @returns A @ref mongocrypt_ctx_state_t."]
    pub fn mongocrypt_ctx_state(ctx: *mut mongocrypt_ctx_t) -> mongocrypt_ctx_state_t;
}
extern "C" {
    #[doc = " Get BSON necessary to run the mongo operation when mongocrypt_ctx_t"]
    #[doc = " is in MONGOCRYPT_CTX_NEED_MONGO_* states."]
    #[doc = ""]
    #[doc = " @p op_bson is a BSON document to be used for the operation."]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_COLLINFO it is a listCollections filter."]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_KEYS it is a find filter."]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_MARKINGS it is a command to send to"]
    #[doc = " mongocryptd."]
    #[doc = ""]
    #[doc = " The lifetime of @p op_bson is tied to the lifetime of @p ctx. It is valid"]
    #[doc = " until @ref mongocrypt_ctx_destroy is called."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[out] op_bson A BSON document for the MongoDB operation. The data"]
    #[doc = " viewed by @p op_bson is guaranteed to be valid until @p ctx is destroyed with"]
    #[doc = " @ref mongocrypt_ctx_destroy."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_mongo_op(
        ctx: *mut mongocrypt_ctx_t,
        op_bson: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Feed a BSON reply or result when mongocrypt_ctx_t is in"]
    #[doc = " MONGOCRYPT_CTX_NEED_MONGO_* states. This may be called multiple times"]
    #[doc = " depending on the operation."]
    #[doc = ""]
    #[doc = " reply is a BSON document result being fed back for this operation."]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_COLLINFO it is a doc from a listCollections"]
    #[doc = " cursor. (Note, if listCollections returned no result, do not call this"]
    #[doc = " function.)"]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_KEYS it is a doc from a find cursor."]
    #[doc = "   (Note, if find returned no results, do not call this function. reply must"]
    #[doc = " not"]
    #[doc = "   be NULL.)"]
    #[doc = " - For MONGOCRYPT_CTX_NEED_MONGO_MARKINGS it is a reply from mongocryptd."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] reply A BSON document for the MongoDB operation. The viewed data"]
    #[doc = " is copied. It is valid to destroy @p reply with @ref"]
    #[doc = " mongocrypt_binary_destroy immediately after."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_mongo_feed(
        ctx: *mut mongocrypt_ctx_t,
        reply: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Call when done feeding the reply (or replies) back to the context."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_mongo_done(ctx: *mut mongocrypt_ctx_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mongocrypt_kms_ctx_t {
    _unused: [u8; 0],
}
#[doc = " Manages a single KMS HTTP request/response."]
pub type mongocrypt_kms_ctx_t = _mongocrypt_kms_ctx_t;
extern "C" {
    #[doc = " Get the next KMS handle."]
    #[doc = ""]
    #[doc = " Multiple KMS handles may be retrieved at once. Drivers may do this to fan"]
    #[doc = " out multiple concurrent KMS HTTP requests. Feeding multiple KMS requests"]
    #[doc = " is thread-safe."]
    #[doc = ""]
    #[doc = " If KMS handles are being handled synchronously, the driver can reuse the same"]
    #[doc = " TLS socket to send HTTP requests and receive responses."]
    #[doc = ""]
    #[doc = " @param[in] ctx A @ref mongocrypt_ctx_t."]
    #[doc = " @returns a new @ref mongocrypt_kms_ctx_t or NULL."]
    pub fn mongocrypt_ctx_next_kms_ctx(ctx: *mut mongocrypt_ctx_t) -> *mut mongocrypt_kms_ctx_t;
}
extern "C" {
    #[doc = " Get the HTTP request message for a KMS handle."]
    #[doc = ""]
    #[doc = " The lifetime of @p msg is tied to the lifetime of @p kms. It is valid"]
    #[doc = " until @ref mongocrypt_ctx_kms_done is called."]
    #[doc = ""]
    #[doc = " @param[in] kms A @ref mongocrypt_kms_ctx_t."]
    #[doc = " @param[out] msg The HTTP request to send to KMS. The data viewed by @p msg is"]
    #[doc = " guaranteed to be valid until the call of @ref mongocrypt_ctx_kms_done of the"]
    #[doc = " parent @ref mongocrypt_ctx_t."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_kms_ctx_status"]
    pub fn mongocrypt_kms_ctx_message(
        kms: *mut mongocrypt_kms_ctx_t,
        msg: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the hostname from which to connect over TLS."]
    #[doc = ""]
    #[doc = " The storage for @p endpoint is not owned by the caller, but"]
    #[doc = " is valid until calling @ref mongocrypt_ctx_kms_done."]
    #[doc = ""]
    #[doc = " @param[in] kms A @ref mongocrypt_kms_ctx_t."]
    #[doc = " @param[out] endpoint The output endpoint as a NULL terminated string."]
    #[doc = " The endpoint consists of a hostname and port separated by a colon."]
    #[doc = " E.g. \"example.com:123\". A port is always present."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_kms_ctx_status"]
    pub fn mongocrypt_kms_ctx_endpoint(
        kms: *mut mongocrypt_kms_ctx_t,
        endpoint: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Indicates how many bytes to feed into @ref mongocrypt_kms_ctx_feed."]
    #[doc = ""]
    #[doc = " @param[in] kms The @ref mongocrypt_kms_ctx_t."]
    #[doc = " @returns The number of requested bytes."]
    pub fn mongocrypt_kms_ctx_bytes_needed(kms: *mut mongocrypt_kms_ctx_t) -> u32;
}
extern "C" {
    #[doc = " Feed bytes from the HTTP response."]
    #[doc = ""]
    #[doc = " Feeding more bytes than what has been returned in @ref"]
    #[doc = " mongocrypt_kms_ctx_bytes_needed is an error."]
    #[doc = ""]
    #[doc = " @param[in] kms The @ref mongocrypt_kms_ctx_t."]
    #[doc = " @param[in] bytes The bytes to feed. The viewed data is copied. It is valid to"]
    #[doc = " destroy @p bytes with @ref mongocrypt_binary_destroy immediately after."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_kms_ctx_status"]
    pub fn mongocrypt_kms_ctx_feed(
        kms: *mut mongocrypt_kms_ctx_t,
        bytes: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the status associated with a @ref mongocrypt_kms_ctx_t object."]
    #[doc = ""]
    #[doc = " @param[in] kms The @ref mongocrypt_kms_ctx_t object."]
    #[doc = " @param[out] status Receives the status."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    pub fn mongocrypt_kms_ctx_status(
        kms: *mut mongocrypt_kms_ctx_t,
        status: *mut mongocrypt_status_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the KMS provider identifier associated with this KMS request."]
    #[doc = ""]
    #[doc = " This is used to conditionally configure TLS connections based on the KMS"]
    #[doc = " request. It is useful for KMIP, which authenticates with a client"]
    #[doc = " certificate."]
    #[doc = ""]
    #[doc = " @param[in] kms The @ref mongocrypt_kms_ctx_t object."]
    #[doc = " @param[out] len Receives the length of the returned string. It may be NULL."]
    #[doc = " If it is not NULL, it is set to the length of the returned string without"]
    #[doc = " the NULL terminator."]
    #[doc = ""]
    #[doc = " @returns One of the NULL terminated static strings: \"aws\", \"azure\", \"gcp\", or"]
    #[doc = " \"kmip\"."]
    pub fn mongocrypt_kms_ctx_get_kms_provider(
        kms: *mut mongocrypt_kms_ctx_t,
        len: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Call when done handling all KMS contexts."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_kms_done(ctx: *mut mongocrypt_ctx_t) -> bool;
}
extern "C" {
    #[doc = " Call in response to the MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS state"]
    #[doc = " to set per-context KMS provider settings. These follow the same format"]
    #[doc = " as @ref mongocrypt_setopt_kms_providers. If no keys are present in the"]
    #[doc = " BSON input, the KMS provider settings configured for the @ref mongocrypt_t"]
    #[doc = " at initialization are used."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] kms_providers A BSON document mapping the KMS provider names"]
    #[doc = " to credentials."]
    #[doc = ""]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status."]
    pub fn mongocrypt_ctx_provide_kms_providers(
        ctx: *mut mongocrypt_ctx_t,
        kms_providers_definition: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform the final encryption or decryption."]
    #[doc = ""]
    #[doc = " @param[in] ctx A @ref mongocrypt_ctx_t."]
    #[doc = " @param[out] out The final BSON. The data viewed by @p out is guaranteed"]
    #[doc = " to be valid until @p ctx is destroyed with @ref mongocrypt_ctx_destroy."]
    #[doc = " The meaning of this BSON depends on the type of @p ctx."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_encrypt_init, then"]
    #[doc = " this BSON is the (possibly) encrypted command to send to the server."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_decrypt_init, then"]
    #[doc = " this BSON is the decrypted result to return to the user."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_explicit_encrypt_init,"]
    #[doc = " then this BSON has the form { \"v\": (BSON binary) } where the BSON binary"]
    #[doc = " is the resulting encrypted value."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_explicit_decrypt_init,"]
    #[doc = " then this BSON has the form { \"v\": (BSON value) } where the BSON value"]
    #[doc = " is the resulting decrypted value."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_datakey_init, then"]
    #[doc = " this BSON is the document containing the new data key to be inserted into"]
    #[doc = " the key vault collection."]
    #[doc = ""]
    #[doc = " If @p ctx was initialized with @ref mongocrypt_ctx_rewrap_many_datakey_init,"]
    #[doc = " then this BSON has the form:"]
    #[doc = "   { \"v\": [{ \"_id\": ..., \"keyMaterial\": ..., \"masterKey\": ... }, ...] }"]
    #[doc = " where each BSON document in the array contains the updated fields of a"]
    #[doc = " rewrapped datakey to be bulk-updated into the key vault collection."]
    #[doc = " Note: the updateDate field should be updated using the $currentDate operator."]
    #[doc = ""]
    #[doc = " @returns a bool indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_finalize(
        ctx: *mut mongocrypt_ctx_t,
        out: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Destroy and free all memory associated with a @ref mongocrypt_ctx_t."]
    #[doc = ""]
    #[doc = " @param[in] ctx A @ref mongocrypt_ctx_t."]
    pub fn mongocrypt_ctx_destroy(ctx: *mut mongocrypt_ctx_t);
}
#[doc = " An crypto AES-256-CBC encrypt or decrypt function."]
#[doc = ""]
#[doc = " Note, @p in is already padded. Encrypt with padding disabled."]
#[doc = " @param[in] ctx An optional context object that may have been set when hooks"]
#[doc = " were enabled."]
#[doc = " @param[in] key An encryption key (32 bytes for AES_256)."]
#[doc = " @param[in] iv An initialization vector (16 bytes for AES_256);"]
#[doc = " @param[in] in The input."]
#[doc = " @param[out] out A preallocated byte array for the output. See @ref"]
#[doc = " mongocrypt_binary_data."]
#[doc = " @param[out] bytes_written Set this to the number of bytes written to @p out."]
#[doc = " @param[out] status An optional status to pass error messages. See @ref"]
#[doc = " mongocrypt_status_set."]
#[doc = " @returns A boolean indicating success. If returning false, set @p status"]
#[doc = " with a message indiciating the error using @ref mongocrypt_status_set."]
pub type mongocrypt_crypto_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        key: *mut mongocrypt_binary_t,
        iv: *mut mongocrypt_binary_t,
        in_: *mut mongocrypt_binary_t,
        out: *mut mongocrypt_binary_t,
        bytes_written: *mut u32,
        status: *mut mongocrypt_status_t,
    ) -> bool,
>;
#[doc = " A crypto signature or HMAC function."]
#[doc = ""]
#[doc = " Currently used in callbacks for HMAC SHA-512, HMAC SHA-256, and RSA SHA-256"]
#[doc = " signature."]
#[doc = ""]
#[doc = " @param[in] ctx An optional context object that may have been set when hooks"]
#[doc = " were enabled."]
#[doc = " @param[in] key An encryption key (32 bytes for HMAC_SHA512)."]
#[doc = " @param[in] in The input."]
#[doc = " @param[out] out A preallocated byte array for the output. See @ref"]
#[doc = " mongocrypt_binary_data."]
#[doc = " @param[out] status An optional status to pass error messages. See @ref"]
#[doc = " mongocrypt_status_set."]
#[doc = " @returns A boolean indicating success. If returning false, set @p status"]
#[doc = " with a message indiciating the error using @ref mongocrypt_status_set."]
pub type mongocrypt_hmac_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        key: *mut mongocrypt_binary_t,
        in_: *mut mongocrypt_binary_t,
        out: *mut mongocrypt_binary_t,
        status: *mut mongocrypt_status_t,
    ) -> bool,
>;
#[doc = " A crypto hash (SHA-256) function."]
#[doc = ""]
#[doc = " @param[in] ctx An optional context object that may have been set when hooks"]
#[doc = " were enabled."]
#[doc = " @param[in] in The input."]
#[doc = " @param[out] out A preallocated byte array for the output. See @ref"]
#[doc = " mongocrypt_binary_data."]
#[doc = " @param[out] status An optional status to pass error messages. See @ref"]
#[doc = " mongocrypt_status_set."]
#[doc = " @returns A boolean indicating success. If returning false, set @p status"]
#[doc = " with a message indiciating the error using @ref mongocrypt_status_set."]
pub type mongocrypt_hash_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        in_: *mut mongocrypt_binary_t,
        out: *mut mongocrypt_binary_t,
        status: *mut mongocrypt_status_t,
    ) -> bool,
>;
#[doc = " A crypto secure random function."]
#[doc = ""]
#[doc = " @param[in] ctx An optional context object that may have been set when hooks"]
#[doc = " were enabled."]
#[doc = " @param[out] out A preallocated byte array for the output. See @ref"]
#[doc = " mongocrypt_binary_data."]
#[doc = " @param[in] count The number of random bytes requested."]
#[doc = " @param[out] status An optional status to pass error messages. See @ref"]
#[doc = " mongocrypt_status_set."]
#[doc = " @returns A boolean indicating success. If returning false, set @p status"]
#[doc = " with a message indiciating the error using @ref mongocrypt_status_set."]
pub type mongocrypt_random_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        out: *mut mongocrypt_binary_t,
        count: u32,
        status: *mut mongocrypt_status_t,
    ) -> bool,
>;
extern "C" {
    pub fn mongocrypt_setopt_crypto_hooks(
        crypt: *mut mongocrypt_t,
        aes_256_cbc_encrypt: mongocrypt_crypto_fn,
        aes_256_cbc_decrypt: mongocrypt_crypto_fn,
        random: mongocrypt_random_fn,
        hmac_sha_512: mongocrypt_hmac_fn,
        hmac_sha_256: mongocrypt_hmac_fn,
        sha_256: mongocrypt_hash_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a crypto hook for the AES256-CTR operations."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] aes_256_ctr_encrypt The crypto callback function for encrypt"]
    #[doc = " operation."]
    #[doc = " @param[in] aes_256_ctr_decrypt The crypto callback function for decrypt"]
    #[doc = " operation."]
    #[doc = " @param[in] ctx A context passed as an argument to the crypto callback"]
    #[doc = " every invocation."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_status"]
    #[doc = ""]
    pub fn mongocrypt_setopt_aes_256_ctr(
        crypt: *mut mongocrypt_t,
        aes_256_ctr_encrypt: mongocrypt_crypto_fn,
        aes_256_ctr_decrypt: mongocrypt_crypto_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set an AES256-ECB crypto hook for the AES256-CTR operations. If CTR hook was"]
    #[doc = " configured using @ref mongocrypt_setopt_aes_256_ctr, ECB hook will be"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] aes_256_ecb_encrypt The crypto callback function for encrypt"]
    #[doc = " operation."]
    #[doc = " @param[in] ctx A context passed as an argument to the crypto callback"]
    #[doc = " every invocation."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_status"]
    #[doc = ""]
    pub fn mongocrypt_setopt_aes_256_ecb(
        crypt: *mut mongocrypt_t,
        aes_256_ecb_encrypt: mongocrypt_crypto_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a crypto hook for the RSASSA-PKCS1-v1_5 algorithm with a SHA-256 hash."]
    #[doc = ""]
    #[doc = " See: https://tools.ietf.org/html/rfc3447#section-8.2"]
    #[doc = ""]
    #[doc = " Note: this function has the wrong name. It should be:"]
    #[doc = " mongocrypt_setopt_crypto_hook_sign_rsassa_pkcs1_v1_5"]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object."]
    #[doc = " @param[in] sign_rsaes_pkcs1_v1_5 The crypto callback function."]
    #[doc = " @param[in] sign_ctx A context passed as an argument to the crypto callback"]
    #[doc = " every invocation."]
    #[doc = " @pre @ref mongocrypt_init has not been called on @p crypt."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_status"]
    #[doc = ""]
    pub fn mongocrypt_setopt_crypto_hook_sign_rsaes_pkcs1_v1_5(
        crypt: *mut mongocrypt_t,
        sign_rsaes_pkcs1_v1_5: mongocrypt_hmac_fn,
        sign_ctx: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Opt-into skipping query analysis."]
    #[doc = ""]
    #[doc = " If opted in:"]
    #[doc = " - The crypt_shared library will not attempt to be loaded."]
    #[doc = " - A mongocrypt_ctx_t will never enter the MONGOCRYPT_CTX_NEED_MARKINGS state."]
    #[doc = ""]
    #[doc = " @param[in] crypt The @ref mongocrypt_t object to update"]
    pub fn mongocrypt_setopt_bypass_query_analysis(crypt: *mut mongocrypt_t);
}
extern "C" {
    #[doc = " Set the contention factor used for explicit encryption."]
    #[doc = " The contention factor is only used for indexed Queryable Encryption."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] contention_factor"]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status."]
    pub fn mongocrypt_ctx_setopt_contention_factor(
        ctx: *mut mongocrypt_ctx_t,
        contention_factor: i64,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the index key id to use for explicit Queryable Encryption."]
    #[doc = ""]
    #[doc = " If the index key id not set, the key id from @ref"]
    #[doc = " mongocrypt_ctx_setopt_key_id is used."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] key_id The binary corresponding to the _id (a UUID) of the data"]
    #[doc = " key to use from the key vault collection. Note, the UUID must be encoded with"]
    #[doc = " RFC-4122 byte order. The viewed data is copied. It is valid to destroy"]
    #[doc = " @p key_id with @ref mongocrypt_binary_destroy immediately after."]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_index_key_id(
        ctx: *mut mongocrypt_ctx_t,
        key_id: *mut mongocrypt_binary_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the query type to use for explicit Queryable Encryption."]
    #[doc = ""]
    #[doc = " @param[in] ctx The @ref mongocrypt_ctx_t object."]
    #[doc = " @param[in] query_type The query type string"]
    #[doc = " @param[in] len The length of query_type, or -1 for automatic"]
    #[doc = " @pre @p ctx has not been initialized."]
    #[doc = " @returns A boolean indicating success. If false, an error status is set."]
    #[doc = " Retrieve it with @ref mongocrypt_ctx_status"]
    pub fn mongocrypt_ctx_setopt_query_type(
        ctx: *mut mongocrypt_ctx_t,
        query_type: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
